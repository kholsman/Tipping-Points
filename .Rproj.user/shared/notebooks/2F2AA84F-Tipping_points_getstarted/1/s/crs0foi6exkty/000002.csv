"0","  # ----------------------------------------"
"0","  # Calculate vertical component of resilience"
"0","  # ----------------------------------------"
"0",""
"0","  # here I'm simply using the residuals for this, but one could calculate actual distance"
"0","  # of point from line (but little effect on the shape of the stability landscape)"
"0","  Data_prev <- Data # archive  # Data <- Data_prev"
"0","  Data$vc   <- abs(TGAM$res$residuals)"
"0","  "
"0","  # Identify the position of tipping points"
"0","  # ----------------------------------------"
"0",""
"0","  # First tipping point(F1):"
"0","  Data                <- rbind(Data, c(""F1"",NA,NA,0)) #F1 obviously has vc=0 "
"0","  Data[,2:ncol(Data)] <- sapply(Data[,2:ncol(Data)],as.numeric)"
"0",""
"0","  "
"0","  # calculate x-value (pc1str) of F1"
"0","  # may add -1 here to force tipping year's resilience not to be calculated based on upper branch"
"0","  ff1 <- which.max(rowSums(Data[1:which(Data$year == round(TGAM$mr)),3:4])+0.1) "
"0","  ff1 <- names(ff1)"
"0","  Data[nrow(Data),3]<- -abs(Data[ff1,3])-abs(Data[ff1,ncol(Data)])"
"0","  # this x-value for F1 ensures that all Res estimates of upper branch will be non-negative. "
"0","  # 0.05 is arbitrary to give some extra space - can be omitted"
"0","  "
"0","  # calculate y-value (pc1sys) of F1"
"0","  o <- gam(pc1sys~s(pc1str, k=3), data=rbind(Dataup,Data[NROW(Data),1:3]))"
"0","  Data[nrow(Data),2] <- predict.gam(o, newdata=data.frame(pc1str=Data[nrow(Data),3]))"
"0","  "
"0","  #Second tipping point (F2):"
"0","  Data                <- rbind(Data, c(""F2"",NA,NA,0))"
"0","  Data[,2:ncol(Data)] <- sapply(Data[,2:ncol(Data)],as.numeric)"
"0","  #Data$vc<--Data$vc"
"0","  "
"0","  #calculate x-value (pc1str) of F2"
"0","  ff2 <- which.max(rowSums(Data[which(Data$year == round(TGAM$mr)+1):NROW(Data),3:4]))"
"0","  ff2 <- names(ff2)"
"0","  Data[nrow(Data),3]<-Data[ff2,3]+abs(Data[ff2,ncol(Data)]+0.1)"
"0","  #this x-value for F2 ensures that all Res estimates of lower branch will be non-negative."
"0","  #0.05 is arbitrary to give some extra space"
"0","  "
"0","  #calculate y-value (pc1sys) of F2"
"0","  p <- gam(pc1sys~s(pc1str, k=3), data=rbind(Datalow,Data[NROW(Data),1:3]))"
"0","  Data[nrow(Data),2] <- predict.gam(p, newdata=data.frame(pc1str=Data[nrow(Data),3]))"
"0",""
"0",""
"0","  # ----------------------------------------"
"0","  # calculate the horizontal component of resilience"
"0","  # ----------------------------------------"
"0","  Data$hc     <- NA"
"0","  rr          <- 1:which(Data$year == round(TGAM$mr))"
"0","  Data$hc[rr] <- abs(Data$pc1str[nrow(Data)-1]-Data$pc1str[rr])"
"0",""
"0","  rr          <- which(Data$year == round(TGAM$mr)+1):(nrow(Data)-2)"
"0","  Data$hc[rr] <- abs(Data$pc1str[rr]- Data$pc1str[nrow(Data)])"
"0","  Data$hc[(nrow(Data)-1):nrow(Data)] <- 0"
"0","  "
"0","  #calculate resilience"
"0","  Data$res  <- Data$hc - Data$vc"
"0","  Data$res[13] = 0  # manually set because it is unclear if part of first or second state"
"0","  "
"0","  #calculate relative resilience"
"0","  Data$relres <- Data$res/max(Data$res , na.rm =T)"
"0","  "
"0","  #prepare line extensions to tipping points"
"0","  newdata3 <- data.frame(pc1str=runif(100,Data$pc1str[NROW(Data)-1],min(Dataup$pc1str)))"
"0","  newdata4 <- data.frame(pc1str=runif(100,max(Datalow$pc1str),Data$pc1str[NROW(Data)]))"
"0","  x        <- predict.gam(o,newdata3)"
"0","  w        <- predict.gam(p,newdata4)"
"0",""
"0","  "
